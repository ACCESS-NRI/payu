#!/usr/bin/env python
# coding: utf-8

import argparse
import os
import payu
import sys
import shlex
from socket import gethostname
import subprocess as sp
import yaml

# TODO: Move to payu (somehow)
model_index = {'mom': payu.Mom,
               'mom4': payu.mom4,
               'mitgcm': payu.mitgcm,
               'gold': payu.gold}
default_config_fname = 'config.yaml'


#----------------
def payu_parse():

    #------------------
    # Parser generation

    parser = argparse.ArgumentParser()

    parser.add_argument('-m', '--model',
                        action='store',
                        dest='model_name',
                        default=None,
                        help='Select model type')

    parser.add_argument('-c', '--config',
                        action='store',
                        dest='config_path',
                        default=None,
                        help='Configuration path')

    subcmd = parser.add_subparsers()

    sweep_cmd = subcmd.add_parser('sweep')
    sweep_cmd.set_defaults(cmd=call_sweep)

    sweep_cmd.add_argument('--hard',
                           action='store_true',
                           dest='hard_sweep')

    list_cmd = subcmd.add_parser('list')
    list_cmd.set_defaults(cmd=call_list)

    run_cmd = subcmd.add_parser('run')
    run_cmd.set_defaults(cmd=call_run)

    run_cmd.add_argument('--initial', '-i',
                         action='store',
                         dest='init_run')

    run_cmd.add_argument('--nruns', '-n',
                         action='store',
                         dest='n_runs')

    collate_cmd = subcmd.add_parser('collate')
    collate_cmd.set_defaults(cmd=call_collate)

    collate_cmd.add_argument('--initial', '-i',
                         action='store',
                         dest='init_run')

    collate_cmd.add_argument('--nruns', '-n',
                         action='store',
                         dest='n_runs')

    args = parser.parse_args()

    # Skip validation when listing supported models
    if args.cmd == call_list:
        call_list()
        sys.exit()

    config_path = args.config_path
    model_name = args.model_name

    #--------------------
    # Payu tag validation

    # Validate the configuration file path
    if config_path and not os.path.isfile(config_path):
        sys.exit('payu: error: Configuration file {f} does not exist.'.format(
                    f=config_path))

    # Assign the default config path if it exists
    if not config_path and os.path.isfile(default_config_fname):
        config_path = os.path.join(os.curdir, default_config_fname)

    # If no model name is specified, then check the config path
    if not model_name and config_path and os.path.isfile(config_path):
        with open(config_path, 'r') as config_file:
            config = yaml.load(config_file)
        model_name = config.get('model')

    # If there is still no defined model_name, try the parent directory
    if not model_name:
        model_name = os.path.basename(os.path.abspath(os.pardir))
        if not model_name in model_index.keys():
            sys.exit('payu: error: Unknown model.')
        else:
            print('payu: warning: Assuming model is {model} based on '
                  'parent directory name.'.format(model=model_name))

    #---
    # Counters
    if args.cmd in (call_run, call_collate):
        # TODO: Set defaults to "None", move these calcs to payu.py
        counter = int(args.init_run or 0)
        assert counter >= 0

        n_runs = int(args.n_runs or 1)
        assert n_runs > 0
        max_counter = counter + n_runs - 1

        args.cmd(model_name, config_path, counter, max_counter)

    elif args.cmd == call_sweep:
        call_sweep(model_name, config_path, args.hard_sweep)

    else:
        # NOTE: Unnecessary; argparse already checks subcommands
        sys.exit("payu: Unknown subcommand {0}".format(args.cmd))


#--
def submit_job(pbs_script, pbs_config, pbs_vars=None):

    pbs_qsub = 'qsub'
    pbs_flags = []

    pbs_queue = pbs_config.get('queue', 'normal')
    if pbs_queue:
        pbs_flags.append('-q {0}'.format(pbs_queue))

    # Raijin doesn't read $PROJECT, which is required at login
    pbs_project = pbs_config.get('project', os.environ['PROJECT'])
    pbs_flags.append('-P {0}'.format(pbs_project))

    pbs_walltime = pbs_config.get('walltime')
    if pbs_walltime:
        pbs_flags.append('-l walltime={0}'.format(pbs_walltime))

    pbs_ncpus = pbs_config.get('ncpus')
    if pbs_ncpus:
        pbs_flags.append('-l ncpus={0}'.format(pbs_ncpus))

    pbs_mem = pbs_config.get('mem')
    if pbs_mem:
        mem_rname = 'vmem' if gethostname().startswith('vayu') else 'mem'
        pbs_flags.append('-l {0}={1}'.format(mem_rname, pbs_mem))

    # TODO: Raijin forces a 15 character limit (vayu too?)
    pbs_jobname = pbs_config.get('jobname')
    if pbs_jobname:
        if gethostname().startswith('raijin'):
            pbs_jobname = pbs_jobname[:15]
        pbs_flags.append('-N {0}'.format(pbs_jobname))

    pbs_wd = '-wd' if gethostname().startswith('vayu') else '-l wd'
    pbs_flags.append(pbs_wd)

    # TODO: Make this optional
    pbs_flags.append('-j oe')

    if pbs_vars:
        pbs_vstring = ','.join("{0}={1}".format(k, v)
                                for k, v in pbs_vars.iteritems())
        pbs_flags.append('-v ' + pbs_vstring)

    # Collect flags
    pbs_flags = ' '.join(pbs_flags)

    # Construct full command
    cmd = '{0} {1} {2}'.format(pbs_qsub, pbs_flags, pbs_script)

    # Parse and execute
    cmd = shlex.split(cmd)
    rc = sp.call(cmd)
    assert rc == 0


#--
def call_run(model_name, config_path, counter, max_counter):

    # TODO: Is config_path always defined?
    with open(config_path, 'r') as config_file:
        config = yaml.load(config_file)

    # Set the queue
    config['queue'] = 'normal'

    # Set environment variables
    pbs_vars = {'model': model_name}
    if counter:
        pbs_vars['count'] = counter
    if max_counter:
        pbs_vars['max'] = max_counter

    run_script = os.path.join(os.path.dirname(__file__), 'payu-run')
    submit_job(run_script, config, pbs_vars)


#--
def call_collate(model_name, config_path, counter, max_counter):

    # TODO: Is config_path always defined?
    with open(config_path, 'r') as config_file:
        config = yaml.load(config_file)

    # Set the queue
    config['queue'] = 'copyq'

    # Replace (or remove) walltime
    collate_walltime = config.get('collate_walltime')
    if collate_walltime:
        config['walltime'] = collate_walltime
    else:
        # Remove the model walltime if set
        try:
            config.pop('walltime')
        except KeyError:
            pass

    # Replace (or remove) memory request
    collate_mem = config.get('collate_mem')
    if collate_mem:
        config['mem'] = collate_mem
    else:
        # Remove the model memory request if set
        try:
            config.pop('mem')
        except KeyError:
            pass

    # Set environment variables
    pbs_vars = {'model': model_name}
    if counter:
        pbs_vars['count'] = counter
    if max_counter:
        pbs_vars['max'] = max_counter

    run_script = os.path.join(os.path.dirname(__file__), 'payu-collate')
    submit_job(run_script, config, pbs_vars)


#---
def call_sweep(model_name, config_path, hard_sweep=False):

    cmd = 'payu-sweep -m {0} -c {1}'.format(model_name, config_path)
    if hard_sweep:
        cmd = ' '.join([cmd, '--hard'])

    cmd = shlex.split(cmd)
    rc = sp.call(cmd)
    assert rc == 0


#---
def call_list():
    print('Supported models: {0}'.format(' '.join(model_index.keys())))


#-------------------------
if __name__ == '__main__':

    # Default to display help if no subcommands or arguments are provided
    if len(sys.argv) == 1:
        sys.argv.append('-h')

    payu_parse()
